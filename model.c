#include <stdlib.h>
#include <stdio.h>
#include <math.h>
/* This files provides address values that exist in the system */

#define SDRAM_BASE            0xC0000000
#define FPGA_ONCHIP_BASE      0xC8000000
#define FPGA_CHAR_BASE        0xC9000000

/* Cyclone V FPGA devices */
#define LEDR_BASE             0xFF200000
#define HEX3_HEX0_BASE        0xFF200020
#define HEX5_HEX4_BASE        0xFF200030
#define SW_BASE               0xFF200040
#define KEY_BASE              0xFF200050
#define TIMER_BASE            0xFF202000
#define PIXEL_BUF_CTRL_BASE   0xFF203020
#define CHAR_BUF_CTRL_BASE    0xFF203030

/* VGA colors */
#define WHITE 0xFFFF
#define YELLOW 0xFFE0
#define RED 0xF800
#define GREEN 0x07E0
#define BLUE 0x001F
#define CYAN 0x07FF
#define MAGENTA 0xF81F
#define GREY 0xC618
#define PINK 0xFC18
#define ORANGE 0xFC00

#define ABS(x) (((x) > 0) ? (x) : -(x))

/* Screen size. */
#define RESOLUTION_X 320
#define RESOLUTION_Y 240

/* Constants for animation */
#define BOX_LEN 2
#define NUM_BOXES 8

#define FALSE 0
#define TRUE 1
volatile int * pixel_ctrl_ptr = (int *)0xFF203020;
volatile int * char_ctrl_ptr = (int *)0xFF203030;
volatile int * stat_reg_ptr = (int *)0xFF20302C;
volatile int pixel_buffer_start; // global variable
volatile char char_buffer_start;
volatile int pixel_buffer_last; // global variable

//macros
double sigmoid(double x) { return 1 / (1 + exp(-x)); }
double dSigmoid(double x) { return x * (1 - x); }
double init_weight() { return ((double)rand())/((double)RAND_MAX); }
void wait_for_vsync(){
	volatile int *pixel_ctrl_ptr = 0xFF203020;
	register int status;
	*pixel_ctrl_ptr = 1;
	status = *(pixel_ctrl_ptr+3);
	while((status & 0x01) !=0){
		status = *(pixel_ctrl_ptr+3);
	}
}
void clear_screen(){
    for (int x = 0; x< 320; x++){
        for (int y = 0; y<240; y++){
            plot_pixel(x, y, 0x0);
        }
    }
}
void write_char(int x, int y, char c) {
  // VGA character buffer
   volatile char * character_buffer = (char *) (FPGA_CHAR_BASE + (y<<7) + x);
  *character_buffer = c;
}
void plot_pixel(int x, int y, short int line_color)
{
    *(short int *)(pixel_buffer_start + (y << 10) + (x << 1)) = line_color;
}
void shuffle(int *array, size_t pp)
{
    if (pp > 1)
    {
        size_t i;
        for (i = 0; i < pp - 1; i++)
        {
            size_t j = i + rand() / (RAND_MAX / (pp - i) + 1);
            int t = array[j];
            array[j] = array[i];
            array[i] = t;
        }
    }
}
int correctWrong(int trueInput[], int trueLen, double output[]){
    //printf("trueInput[%d][%d], output[%f][%f]", trueInput[0], trueInput[1], output[0], output[1]);
    int i;
    int correct = 1;
    for (i = 0; i<trueLen; i++){
        if (trueInput[i] == 1){
            if (output[i] > 0.5){
                correct = 1;
            }
            else{
                correct = 0;
                //printf("case 1 pass %d, %d\n", i, correct);
                return correct;
            }
        }
        else if (trueInput[i] == 0){
            if (output[i] > 0.5){
                correct = 0;
                //printf("case 2 %d\n", correct, trueInput[i]);
                return correct; 
            }
            else{
                correct = 1;
            }
        }

    }  
    //printf("case 3 %d\n", correct);
    return correct;
    
}
//data inputted in the most lazy way possible
double temperature[119] = {0.8650602409638554,
0.8650602409638554,
0.8674698795180723,
0.8674698795180723,
0.8674698795180723,
0.8722891566265061,
0.8722891566265061,
0.8746987951807228,
0.8819277108433735,
0.8819277108433735,
0.8819277108433735,
0.8819277108433735,
0.8843373493975905,
0.8843373493975905,
0.8843373493975905,
0.8867469879518072,
0.8867469879518072,
0.8891566265060241,
0.8891566265060241,
0.891566265060241,
0.891566265060241,
0.891566265060241,
0.891566265060241,
0.891566265060241,
0.891566265060241,
0.891566265060241,
0.891566265060241,
0.8939759036144579,
0.8939759036144579,
0.8939759036144579,
0.8963855421686747,
0.8963855421686747,
0.8963855421686747,
0.8987951807228916,
0.8987951807228916,
0.8987951807228916,
0.9012048192771084,
0.9012048192771084,
0.9036144578313253,
0.9036144578313253,
0.9036144578313253,
0.9036144578313253,
0.9036144578313253,
0.9036144578313253,
0.9060240963855422,
0.9060240963855422,
0.9060240963855422,
0.9084337349397591,
0.9084337349397591,
0.9084337349397591,
0.9084337349397591,
0.9108433734939758,
0.9108433734939758,
0.9108433734939758,
0.9132530120481928,
0.9132530120481928,
0.9132530120481928,
0.9132530120481928,
0.9132530120481928,
0.9156626506024096,
0.9156626506024096,
0.9180722891566265,
0.9228915662650602,
0.927710843373494,
0.9325301204819277,
0.9373493975903614,
0.9397590361445783,
0.9493975903614458,
0.9566265060240965,
0.963855421686747,
0.963855421686747,
0.963855421686747,
0.963855421686747,
0.963855421686747,
0.963855421686747,
0.963855421686747,
0.963855421686747,
0.9662650602409639,
0.9686746987951808,
0.9686746987951808,
0.9686746987951808,
0.9710843373493975,
0.9734939759036144,
0.9734939759036144,
0.9734939759036144,
0.9734939759036144,
0.9734939759036144,
0.9759036144578314,
0.9783132530120482,
0.9783132530120482,
0.9783132530120482,
0.9807228915662651,
0.9807228915662651,
0.9807228915662651,
0.9807228915662651,
0.9807228915662651,
0.9831325301204819,
0.9855421686746988,
0.9855421686746988,
0.9855421686746988,
0.9879518072289156,
0.9879518072289156,
0.9879518072289156,
0.9879518072289156,
0.9903614457831326,
0.9903614457831326,
0.9903614457831326,
0.9903614457831326,
0.9903614457831326,
0.9927710843373495,
0.9927710843373495,
0.9927710843373495,
0.9927710843373495,
0.9951807228915662,
0.9975903614457831,
1.0,
1.0,
1.0,
1.0};
int nausea[119] = {0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
1,
1,
1,
0,
0,
1,
1,
0,
1,
1,
0,
1,
0,
1,
1,
1,
0,
1,
1,
1,
0,
1,
1,
1,
0,
1,
0,
0,
1,
1,
0,
1,
0,
1,
0,
1,
1,
0,
1,
0,
1,
0,
1,
0,
1,
0,
0,
1,
0,
0};
int lumbar[119] = {0,
1,
0,
1,
1,
0,
1,
0,
0,
0,
1,
1,
0,
1,
1,
0,
0,
0,
1,
0,
0,
1,
0,
0,
0,
0,
0,
1,
0,
0,
0,
1,
0,
1,
0,
0,
1,
0,
0,
1,
1,
0,
0,
0,
0,
0,
0,
0,
0,
1,
0,
1,
0,
0,
0,
0,
1,
0,
0,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
0,
0,
1,
1,
1,
1,
1,
0,
1,
1,
1,
1,
1,
0,
1,
1,
1,
0,
1,
1,
1,
0,
1,
1,
1,
1,
1,
1,
1,
0,
1,
1,
1,
1,
0,
1,
1,
1,
0,
1,
1,
1,
1,
0,
1,
1,
1
};
int urine[119] = {1,
0,
1,
0,
0,
1,
0,
1,
1,
1,
0,
0,
1,
0,
0,
1,
1,
1,
0,
1,
1,
0,
1,
1,
1,
1,
1,
0,
1,
1,
1,
0,
1,
0,
1,
1,
0,
1,
1,
0,
0,
1,
1,
1,
1,
1,
1,
1,
1,
0,
1,
0,
1,
1,
1,
1,
0,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
0,
0,
0,
0,
1,
1,
1,
0,
0,
1,
1,
1,
1,
0,
0,
1,
1,
0,
0,
1,
1,
0,
0,
1,
1,
1,
1,
1,
1,
0,
0,
1,
1,
1,
0,
0,
1,
1,
0,
0,
1,
1,
1,
0,
0,
1,
1,
};
int micturition[119] = {1,
0,
1,
0,
0,
1,
0,
1,
1,
1,
0,
0,
1,
0,
0,
1,
1,
1,
0,
1,
1,
0,
1,
1,
1,
1,
0,
0,
1,
0,
1,
0,
0,
0,
1,
0,
0,
0,
1,
0,
0,
1,
0,
0,
1,
1,
1,
1,
1,
0,
0,
0,
1,
0,
1,
1,
0,
1,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
1,
1,
1,
0,
0,
1,
1,
0,
1,
1,
0,
1,
0,
1,
1,
1,
0,
1,
1,
1,
0,
1,
1,
1,
0,
1,
0,
0,
1,
1,
0,
1,
0,
1,
0,
1,
1,
0,
1,
0,
1,
0,
1,
0,
1,
0,
0,
1,
0,
0
};
int ppBurn[119] = {1,
0,
1,
0,
0,
1,
0,
1,
1,
1,
0,
0,
1,
0,
0,
1,
1,
1,
0,
0,
0,
0,
1,
1,
1,
1,
0,
0,
1,
0,
0,
0,
0,
0,
1,
0,
0,
0,
0,
0,
0,
1,
0,
0,
0,
0,
1,
0,
0,
0,
0,
0,
1,
0,
0,
0,
0,
1,
0,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
0,
0,
0,
0,
0,
1,
0,
1,
0,
0,
1,
1,
0,
0,
0,
0,
0,
1,
0,
0,
1,
0,
0,
0,
1,
1,
0,
0,
1,
1,
0,
0,
1,
1,
0,
0,
0,
1,
1,
0,
0,
1,
0,
1,
0,
0,
1,
1
};
int inflam[119] = {1,
0,
1,
0,
0,
1,
0,
1,
1,
1,
0,
0,
1,
0,
0,
1,
1,
1,
0,
1,
1,
0,
1,
1,
1,
1,
1,
0,
1,
1,
1,
0,
1,
0,
1,
1,
0,
1,
1,
0,
0,
1,
1,
1,
1,
1,
1,
1,
1,
0,
1,
0,
1,
1,
1,
1,
0,
1,
1,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
1,
1,
1,
0,
0,
0,
0,
0,
1,
1,
0,
0,
0,
1,
1,
1,
0,
0,
1,
1,
0,
0,
1,
1,
0,
0,
0,
0,
1,
1,
0,
1,
0,
0,
0,
1,
1,
0,
0,
0,
1,
0,
0,
0,
1,
0,
0,
0,
0,
0
};
int nephritis[119] = {0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
0,
0,
1,
1,
1,
1,
1,
0,
1,
1,
1,
1,
1,
0,
1,
1,
1,
0,
1,
1,
1,
0,
1,
1,
1,
1,
1,
1,
1,
0,
1,
1,
1,
1,
0,
1,
1,
1,
0,
1,
1,
1,
1,
0,
1,
1,
1
};

//basic initial parameters. numInputs and numOutputs cannot change due to the nature of the data and the desired outputs
static const int num_layers = 2;
static const int numOutputs = 2;


int main(){
    #define numInputs 6
    #define numHiddenNodes 3
    #define numOutputs 2
    #define numTrainingSets 119
    int testingSets = numTrainingSets/2;
    int epochs = 40;
    const double lr = 0.1f;
    double hiddenLayer[numHiddenNodes];
    double outputLayer[numOutputs];
    double hiddenLayerBias[numHiddenNodes];
    double outputLayerBias[numOutputs];
    double hiddenWeights[numInputs][numHiddenNodes];
    double outputWeights[numHiddenNodes][numOutputs];
    *(pixel_ctrl_ptr + 1) = 0xC8000000; // first store the address in the 
	// back buffer
	wait_for_vsync();
    /* initialize a pointer to the pixel buffer, used by drawing functions */
    pixel_buffer_start = *pixel_ctrl_ptr;
	char_buffer_start = *char_ctrl_ptr;
	clear_screen();

    for (int i=0; i<numInputs; i++) {
        for (int j=0; j<numHiddenNodes; j++) {
            hiddenWeights[i][j] = init_weight();
        }
    }
    for (int i=0; i<numHiddenNodes; i++) {
        hiddenLayerBias[i] = init_weight();
        for (int j=0; j<numOutputs; j++) {
            outputWeights[i][j] = init_weight();
            outputLayerBias[i] = init_weight();
        }
    }
    /*for (int i=0; i<numOutputs; i++) {
        outputLayerBias[i] = init_weight();
    }*/
    //change how set order is done. not random

    int trainingSetOrder[119];
    for(int i = 0; i < 119; i++)
    {
        trainingSetOrder[i] = i;
    }

    double training_inputs[numInputs][numTrainingSets] = 
{
{0.8650602409638554,
0.8650602409638554,
0.8674698795180723,
0.8674698795180723,
0.8674698795180723,
0.8722891566265061,
0.8722891566265061,
0.8746987951807228,
0.8819277108433735,
0.8819277108433735,
0.8819277108433735,
0.8819277108433735,
0.8843373493975905,
0.8843373493975905,
0.8843373493975905,
0.8867469879518072,
0.8867469879518072,
0.8891566265060241,
0.8891566265060241,
0.891566265060241,
0.891566265060241,
0.891566265060241,
0.891566265060241,
0.891566265060241,
0.891566265060241,
0.891566265060241,
0.891566265060241,
0.8939759036144579,
0.8939759036144579,
0.8939759036144579,
0.8963855421686747,
0.8963855421686747,
0.8963855421686747,
0.8987951807228916,
0.8987951807228916,
0.8987951807228916,
0.9012048192771084,
0.9012048192771084,
0.9036144578313253,
0.9036144578313253,
0.9036144578313253,
0.9036144578313253,
0.9036144578313253,
0.9036144578313253,
0.9060240963855422,
0.9060240963855422,
0.9060240963855422,
0.9084337349397591,
0.9084337349397591,
0.9084337349397591,
0.9084337349397591,
0.9108433734939758,
0.9108433734939758,
0.9108433734939758,
0.9132530120481928,
0.9132530120481928,
0.9132530120481928,
0.9132530120481928,
0.9132530120481928,
0.9156626506024096,
0.9156626506024096,
0.9180722891566265,
0.9228915662650602,
0.927710843373494,
0.9325301204819277,
0.9373493975903614,
0.9397590361445783,
0.9493975903614458,
0.9566265060240965,
0.963855421686747,
0.963855421686747,
0.963855421686747,
0.963855421686747,
0.963855421686747,
0.963855421686747,
0.963855421686747,
0.963855421686747,
0.9662650602409639,
0.9686746987951808,
0.9686746987951808,
0.9686746987951808,
0.9710843373493975,
0.9734939759036144,
0.9734939759036144,
0.9734939759036144,
0.9734939759036144,
0.9734939759036144,
0.9759036144578314,
0.9783132530120482,
0.9783132530120482,
0.9783132530120482,
0.9807228915662651,
0.9807228915662651,
0.9807228915662651,
0.9807228915662651,
0.9807228915662651,
0.9831325301204819,
0.9855421686746988,
0.9855421686746988,
0.9855421686746988,
0.9879518072289156,
0.9879518072289156,
0.9879518072289156,
0.9879518072289156,
0.9903614457831326,
0.9903614457831326,
0.9903614457831326,
0.9903614457831326,
0.9903614457831326,
0.9927710843373495,
0.9927710843373495,
0.9927710843373495,
0.9927710843373495,
0.9951807228915662,
0.9975903614457831,
1.0,
1.0,
1.0,
1.0},
{0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
1,
1,
1,
0,
0,
1,
1,
0,
1,
1,
0,
1,
0,
1,
1,
1,
0,
1,
1,
1,
0,
1,
1,
1,
0,
1,
0,
0,
1,
1,
0,
1,
0,
1,
0,
1,
1,
0,
1,
0,
1,
0,
1,
0,
1,
0,
0,
1,
0,
0
},
{0,
1,
0,
1,
1,
0,
1,
0,
0,
0,
1,
1,
0,
1,
1,
0,
0,
0,
1,
0,
0,
1,
0,
0,
0,
0,
0,
1,
0,
0,
0,
1,
0,
1,
0,
0,
1,
0,
0,
1,
1,
0,
0,
0,
0,
0,
0,
0,
0,
1,
0,
1,
0,
0,
0,
0,
1,
0,
0,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
0,
0,
1,
1,
1,
1,
1,
0,
1,
1,
1,
1,
1,
0,
1,
1,
1,
0,
1,
1,
1,
0,
1,
1,
1,
1,
1,
1,
1,
0,
1,
1,
1,
1,
0,
1,
1,
1,
0,
1,
1,
1,
1,
0,
1,
1,
1
},
{1,
0,
1,
0,
0,
1,
0,
1,
1,
1,
0,
0,
1,
0,
0,
1,
1,
1,
0,
1,
1,
0,
1,
1,
1,
1,
1,
0,
1,
1,
1,
0,
1,
0,
1,
1,
0,
1,
1,
0,
0,
1,
1,
1,
1,
1,
1,
1,
1,
0,
1,
0,
1,
1,
1,
1,
0,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
0,
0,
0,
0,
1,
1,
1,
0,
0,
1,
1,
1,
1,
0,
0,
1,
1,
0,
0,
1,
1,
0,
0,
1,
1,
1,
1,
1,
1,
0,
0,
1,
1,
1,
0,
0,
1,
1,
0,
0,
1,
1,
1,
0,
0,
1,
1,
},
{1,
0,
1,
0,
0,
1,
0,
1,
1,
1,
0,
0,
1,
0,
0,
1,
1,
1,
0,
1,
1,
0,
1,
1,
1,
1,
0,
0,
1,
0,
1,
0,
0,
0,
1,
0,
0,
0,
1,
0,
0,
1,
0,
0,
1,
1,
1,
1,
1,
0,
0,
0,
1,
0,
1,
1,
0,
1,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
1,
1,
1,
0,
0,
1,
1,
0,
1,
1,
0,
1,
0,
1,
1,
1,
0,
1,
1,
1,
0,
1,
1,
1,
0,
1,
0,
0,
1,
1,
0,
1,
0,
1,
0,
1,
1,
0,
1,
0,
1,
0,
1,
0,
1,
0,
0,
1,
0,
0
},
{1,
0,
1,
0,
0,
1,
0,
1,
1,
1,
0,
0,
1,
0,
0,
1,
1,
1,
0,
0,
0,
0,
1,
1,
1,
1,
0,
0,
1,
0,
0,
0,
0,
0,
1,
0,
0,
0,
0,
0,
0,
1,
0,
0,
0,
0,
1,
0,
0,
0,
0,
0,
1,
0,
0,
0,
0,
1,
0,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
0,
0,
0,
0,
0,
1,
0,
1,
0,
0,
1,
1,
0,
0,
0,
0,
0,
1,
0,
0,
1,
0,
0,
0,
1,
1,
0,
0,
1,
1,
0,
0,
1,
1,
0,
0,
0,
1,
1,
0,
0,
1,
0,
1,
0,
0,
1,
1
}};
    int training_outputs[numOutputs][numTrainingSets] = 
{
{1,
0,
1,
0,
0,
1,
0,
1,
1,
1,
0,
0,
1,
0,
0,
1,
1,
1,
0,
1,
1,
0,
1,
1,
1,
1,
1,
0,
1,
1,
1,
0,
1,
0,
1,
1,
0,
1,
1,
0,
0,
1,
1,
1,
1,
1,
1,
1,
1,
0,
1,
0,
1,
1,
1,
1,
0,
1,
1,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
1,
1,
1,
0,
0,
0,
0,
0,
1,
1,
0,
0,
0,
1,
1,
1,
0,
0,
1,
1,
0,
0,
1,
1,
0,
0,
0,
0,
1,
1,
0,
1,
0,
0,
0,
1,
1,
0,
0,
0,
1,
0,
0,
0,
1,
0,
0,
0,
0,
0
},
{0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
0,
0,
1,
1,
1,
1,
1,
0,
1,
1,
1,
1,
1,
0,
1,
1,
1,
0,
1,
1,
1,
0,
1,
1,
1,
1,
1,
1,
1,
0,
1,
1,
1,
1,
0,
1,
1,
1,
0,
1,
1,
1,
1,
0,
1,
1,
1}};
    
    for (int n=0; n < epochs; n++) {
        shuffle(trainingSetOrder,numTrainingSets);
        int flag = 0;
        for (int x=0; x<testingSets; x++) {
            
            int i = trainingSetOrder[x];
            
            // Forward pass
            
            for (int j=0; j<numHiddenNodes; j++) {
                double activation=hiddenLayerBias[j];
                 for (int k=0; k<numInputs; k++) {
                    activation+=training_inputs[k][i]*hiddenWeights[k][j];
                }
                hiddenLayer[j] = sigmoid(activation);
            }
            
            for (int j=0; j<numOutputs; j++) {
                double activation=outputLayerBias[j];
                for (int k=0; k<numHiddenNodes; k++) {
                    activation+=hiddenLayer[k]*outputWeights[k][j];
                }
                outputLayer[j] = sigmoid(activation);
            }
            
            if (n %50 == 0 && flag == 0){
                flag = 1;
                // printf ("Input:%lg %lg %lg %lg %lg %lg   Output:%lg %lg   Expected Output: %d %d\n",
                //     training_inputs[0][i], training_inputs[1][i],training_inputs[2][i], training_inputs[3][i],training_inputs[4][i], training_inputs[5][i],
                //     outputLayer[0],outputLayer[1], training_outputs[0][i],training_outputs[1][i]);
            }

            //printf("%d", x);
                    
           // Backprop
            double deltaOutput[numOutputs];
            for (int j=0; j<numOutputs; j++) {
                double errorOutput = (training_outputs[j][i]-outputLayer[j]);
                deltaOutput[j] = errorOutput*dSigmoid(outputLayer[j]);
            }
            
            double deltaHidden[numHiddenNodes];
            for (int j=0; j<numHiddenNodes; j++) {
                double errorHidden = 0.0f;
                for(int k=0; k<numOutputs; k++) {
                    errorHidden+=deltaOutput[k]*outputWeights[j][k];
                }
                deltaHidden[j] = errorHidden*dSigmoid(hiddenLayer[j]);
            }
            
            for (int j=0; j<numOutputs; j++) {
                outputLayerBias[j] += deltaOutput[j]*lr;
                for (int k=0; k<numHiddenNodes; k++) {
                    outputWeights[k][j]+=hiddenLayer[k]*deltaOutput[j]*lr;
                }
            }
            
            for (int j=0; j<numHiddenNodes; j++) {
                hiddenLayerBias[j] += deltaHidden[j]*lr;
                for(int k=0; k<numInputs; k++) {
                    hiddenWeights[k][j]+=training_inputs[k][i]*deltaHidden[j]*lr;
                }
            }
            
        }
        


    }
    int totalCorrect = 0;
    for (int x=testingSets; x<numTrainingSets; x++) { 
               
        int i = trainingSetOrder[x];
        for (int j=0; j<numHiddenNodes; j++) {
            double activation=hiddenLayerBias[j];
                for (int k=0; k<numInputs; k++) {
                activation+=training_inputs[k][i]*hiddenWeights[k][j];
            }
            hiddenLayer[j] = sigmoid(activation);
        }
        for (int j=0; j<numOutputs; j++) {
            double activation=outputLayerBias[j];
            for (int k=0; k<numHiddenNodes; k++) {
                activation+=hiddenLayer[k]*outputWeights[k][j];
            }
            outputLayer[j] = sigmoid(activation);
        }
        int currentTrue[numOutputs];
        for (int j = 0; j<numOutputs; j++){
            currentTrue[j] = training_outputs[j][i];
        }
        totalCorrect += correctWrong(currentTrue, numOutputs, outputLayer);
    }
    testingSets = numTrainingSets - testingSets;
    double accuracy = (double)totalCorrect/(double)testingSets * 100;
    char* cntr = "Accuracy: ";
    int leng = 0;
    for (int i = 0; i<10; i++){
        write_char(i, 0, "");
    }
    while(*cntr){
        write_char(leng, 0, *cntr);
        leng++;
        cntr++;
    }
    char result[5];
    sprintf(result, "%f", accuracy);
    for (int i = 0; i<4; i++){
        write_char(leng + i, 0, result[i]);
    }

    //printf("total correct = %d, total sets, %d, accuracy = %0.2f%%\n", totalCorrect, testingSets, accuracy);
     // Print weights
    // fputs ("Final Hidden Weights\n[ ", stdout);
    // for (int j=0; j<numHiddenNodes; j++) {
    //     fputs ("[ ", stdout);
    //     for(int k=0; k<numInputs; k++) {
    //         printf ("%lf ", hiddenWeights[k][j]);
    //     }
    //     fputs ("] ", stdout);
    // }
    
    // fputs ("]\nFinal Hidden Biases\n[ ", stdout);
    // for (int j=0; j<numHiddenNodes; j++) {
    //     printf ("%lf ", hiddenLayerBias[j]);
    // }
    // fputs ("]\nFinal Output Weights", stdout);
    // for (int j=0; j<numOutputs; j++) {
    //     fputs ("[ ", stdout);
    //     for (int k=0; k<numHiddenNodes; k++) {
    //         printf ("%lf ", outputWeights[k][j]);
    //     }
    //     fputs ("]\n", stdout);
    // }
    // fputs ("Final Output Biases\n[ ", stdout);
    // for (int j=0; j<numOutputs; j++) {
    //     printf ("%lf ", outputLayerBias[j]);
        
    // }
    // fputs ("]\n", stdout);
 
    return 0;
    
}